from typing import Any, Dict
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.messages import SystemMessage
from langchain.agents import AgentExecutor, create_tool_calling_agent
from langchain.tools import StructuredTool # <--- CHANGED THIS
from pydantic import BaseModel, Field # <--- ADDED THIS

# Import your prompts and Llm
from components.prompts import *
from components.tools import get_clinical_summary, get_process_map, get_intent_map
from components.llm import Llm
from langchain.prompts import PromptTemplate

# LLM initialisation:
obj_llm = Llm()
model = obj_llm.model

# --- DEFINING INPUT SCHEMAS ---
# This tells the Agent: "You must provide TWO specific inputs."
class AgentInput(BaseModel):
    query: str = Field(description="The user's query or the question being asked.")
    demo_name: str = Field(description="The demo_name variable from the state (e.g., 'outreach_engagement_1'). DO NOT guess the name.")

# --- UPDATED EXECUTION FUNCTIONS ---
# Notice we now accept two distinct arguments, not a single string
def execute_call_initiation_agent(query: str, demo_name: str) -> str:
    print(f"DEBUG: call_initiation invoked with demo_name: {demo_name}")
    result = call_initiation_agent_executor.invoke({
        "input": query, 
        "demo_name": demo_name,
        "get_clinical_summary": "", 
        "get_process_map": ""
    })
    return result["output"]

def execute_symptom_grievances_agent(query: str, demo_name: str) -> str:
    result = symptom_grievances_agent_executor.invoke({"input": query, "demo_name": demo_name})
    return result["output"]

def execute_medication_and_pain_management_agent(query: str, demo_name: str) -> str:
    result = medication_and_pain_management_agent_executor.invoke({"input": query, "demo_name": demo_name})
    return result["output"]

def execute_services_and_assistance_agent(query: str, demo_name: str) -> str:
    result = services_and_assistance_agent_executor.invoke({"input": query, "demo_name": demo_name})
    return result["output"]

def execute_call_closure_agent(query: str, demo_name: str) -> str:
    result = call_closure_agent_executor.invoke({"input": query, "demo_name": demo_name})
    return result["output"]

# --- UPDATED TOOL DEFINITIONS ---
# We use StructuredTool.from_function and pass the 'args_schema'

call_initiation_agent_tool = StructuredTool.from_function(
    func=execute_call_initiation_agent,
    name="call_initiation_expert_agent",
    description="Use this when the nurse asks for Identity Verification, DOB, or Name confirmation.",
    args_schema=AgentInput
)

symptom_grievances_agent_tool = StructuredTool.from_function(
    func=execute_symptom_grievances_agent,
    name="symptom_grievances_expert_agent",
    description="Use this when the nurse asks about symptoms, pain, or health complaints.",
    args_schema=AgentInput
)

medication_and_pain_management_agent_tool = StructuredTool.from_function(
    func=execute_medication_and_pain_management_agent,
    name="medication_and_pain_management_expert_agent",
    description="Use this when the nurse asks about medications, prescriptions, or pain levels.",
    args_schema=AgentInput
)

services_and_assistance_agent_tool = StructuredTool.from_function(
    func=execute_services_and_assistance_agent,
    name="services_and_assistance_expert_agent",
    description="Use this when the nurse asks about transportation, food, or social services.",
    args_schema=AgentInput
)

call_closure_agent_tool = StructuredTool.from_function(
    func=execute_call_closure_agent,
    name="call_closure_expert_agent",
    description="Use this when the call is ending.",
    args_schema=AgentInput
)

# --- ORCHESTRATOR SETUP ---
main_tools = [
    call_initiation_agent_tool, 
    symptom_grievances_agent_tool, 
    medication_and_pain_management_agent_tool, 
    services_and_assistance_agent_tool, 
    call_closure_agent_tool, 
    get_intent_map
]

# (Keep your build_agent_executors logic below this line as is)
def build_agent_executors(llm_model, prompt_val, tools_list):
    prompt_template = ChatPromptTemplate.from_messages([
        SystemMessage(content=prompt_val),
        MessagesPlaceholder(variable_name="chat_history"),
        ("human", "{input}"),
        MessagesPlaceholder(variable_name="agent_scratchpad"),
    ])
    
    agent_template = create_tool_calling_agent(llm=llm_model, tools=tools_list, prompt=prompt_template)
    
    return AgentExecutor(
        agent=agent_template, 
        tools=tools_list, 
        verbose=True, # Set to True for debugging
        handle_parsing_errors=True
    )

# ... (Initialize your Sub-Agent Executors like before) ...
# Example:
call_initiation_agent_executor = build_agent_executors(model, call_initiation_prompt, [get_process_map, get_clinical_summary])
symptom_grievances_agent_executor = build_agent_executors(model, symptom_clarification_customer_grievances_prompt, [get_clinical_summary])
# ... etc ...

main_agent = build_agent_executors(model, main_prompt, main_tools)


main_prompt = """
You are playing the role of a CUSTOMER/PATIENT.

State Variables:
- Demo Name ID: {demo_name} 

*** CRITICAL INSTRUCTION FOR TOOL USAGE ***
When you call a tool, you must pass TWO arguments:
1. "query": The nurse's question.
2. "demo_name": You MUST use the exact value "{demo_name}" provided in your state.
   - DO NOT extract names from the conversation.
   - If the nurse says "Is this John?", do NOT change the demo_name to "John". Keep using "{demo_name}".

Current Context:
{chat_history}
"""
