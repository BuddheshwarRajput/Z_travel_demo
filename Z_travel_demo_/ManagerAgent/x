
# main_agent.py

# Direct Import!
from prompthub import symptom_grievances, medication_pain, router_system

# Use them directly in your Chain builder
# (You still need to wrap them in ChatPromptTemplate here in your main file)
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder, SystemMessagePromptTemplate

# Build the Template
symptom_prompt_template = ChatPromptTemplate.from_messages([
    SystemMessagePromptTemplate.from_template(symptom_grievances), # <--- Imported Variable
    MessagesPlaceholder(variable_name="chat_history"),
    ("human", "{input}")
])

symptom_chain = symptom_prompt_template | model | StrOutputParser()




import os
import yaml
import sys

# 1. Setup Paths
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
YAML_PATH = os.path.join(BASE_DIR, "prompts.yaml")

# 2. Load YAML Data
def _load_yaml():
    if not os.path.exists(YAML_PATH):
        raise FileNotFoundError(f"Prompt file not found at: {YAML_PATH}")
    with open(YAML_PATH, "r") as f:
        return yaml.safe_load(f) or {}

_data = _load_yaml()

# 3. Inject Shared Persona Logic
# We want to pre-process the strings so {shared_persona} is already filled in.
shared_persona_text = _data.get("shared_persona", "")
processed_prompts = {}

for key, raw_text in _data.items():
    if isinstance(raw_text, str) and "{shared_persona}" in raw_text:
        # Inject the shared text immediately
        processed_prompts[key] = raw_text.replace("{shared_persona}", shared_persona_text)
    else:
        processed_prompts[key] = raw_text

# 4. Expose Variables to Python
# This tricky line adds the dictionary keys to the module's "globals"
# so you can import them as if they were defined in Python.
globals().update(processed_prompts)

# Optional: Define __all__ so IDEs like PyCharm know what's available
__all__ = list(processed_prompts.keys())











import os
import yaml
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder, SystemMessagePromptTemplate

# Locate the YAML file relative to this script
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
YAML_PATH = os.path.join(BASE_DIR, "prompts.yaml")

_PROMPT_CACHE = {}

def load_prompts():
    """Forces a reload of the YAML file (useful for hot-reloading)."""
    global _PROMPT_CACHE
    if not os.path.exists(YAML_PATH):
        raise FileNotFoundError(f"Prompt file not found at: {YAML_PATH}")
        
    with open(YAML_PATH, "r") as f:
        _PROMPT_CACHE = yaml.safe_load(f)

def list_prompts():
    """Returns a list of available prompt keys."""
    if not _PROMPT_CACHE:
        load_prompts()
    return list(_PROMPT_CACHE.keys())

def get_raw_prompt(key: str) -> str:
    """Returns the raw string from YAML, injecting shared persona if needed."""
    if not _PROMPT_CACHE:
        load_prompts()
    
    raw_text = _PROMPT_CACHE.get(key)
    if not raw_text:
        raise KeyError(f"Prompt '{key}' not found in prompts.yaml")
    
    # 1. Fetch Shared Persona
    shared_text = _PROMPT_CACHE.get("shared_persona", "")
    
    # 2. Inject Shared Persona into the specific prompt if the placeholder exists
    # This replaces {shared_persona} in the YAML text with the actual text
    if "{shared_persona}" in raw_text:
        try:
            # We use .replace instead of .format to avoid breaking other {variables}
            raw_text = raw_text.replace("{shared_persona}", shared_text)
        except Exception as e:
            print(f"Error injecting shared persona into {key}: {e}")

    return raw_text

def get_chat_template(key: str) -> ChatPromptTemplate:
    """
    Returns a Ready-to-Use LangChain ChatPromptTemplate.
    Automatically adds the 'chat_history' placeholder and 'human' input.
    """
    system_prompt_str = get_raw_prompt(key)
    
    # Special handling for Router (it doesn't need chat history in your specific flow)
    if key == "router_system":
         return ChatPromptTemplate.from_messages([
            ("system", system_prompt_str),
            ("human", "{input}")
        ])

    # Standard Agent Template (System + History + User)
    return ChatPromptTemplate.from_messages([
        SystemMessagePromptTemplate.from_template(system_prompt_str),
        MessagesPlaceholder(variable_name="chat_history"),
        ("human", "{input}")
    ])

# Load immediately on import
load_prompts()







from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder

# --- ROUTER PROMPT ---
router_system_template = """
You are a router. Your job is to classify the user's input into one of these intents based on the Intent Map provided.
INTENT MAP: {intent_map}

Output ONLY the destination key.
"""

router_prompt_template = ChatPromptTemplate.from_messages([
    ("system", router_system_template),
    ("human", "{input}")
])

# --- SPECIALIST PROMPTS ---

# Medication Agent
medication_system_template = """
You are the Medication and Pain Management Agent. 
You are playing the role of a customer talking to a nurse.

YOUR CLINICAL DATA (Source of Truth):
{clinical_summary}

YOUR DEMOGRAPHICS:
{customer_details}

INSTRUCTIONS:
- Answer based ONLY on the clinical data above.
- If asked about pain, use the pain levels in the data.
- Speak naturally as the patient (first person).
"""

medication_prompt_template = ChatPromptTemplate.from_messages([
    ("system", medication_system_template),
    MessagesPlaceholder(variable_name="chat_history"),
    ("human", "{input}")
])

# Symptom Agent
symptom_system_template = """
You are the Symptom and Grievances Agent.
You are playing the role of a customer.

YOUR CLINICAL DATA (Source of Truth):
{clinical_summary}

INSTRUCTIONS:
- Describe symptoms exactly as they appear in the clinical data.
- If the data says "left leg fracture", do not say "right leg".
"""

symptom_prompt_template = ChatPromptTemplate.from_messages([
    ("system", symptom_system_template),
    MessagesPlaceholder(variable_name="chat_history"),
    ("human", "{input}")
])


from langchain_core.output_parsers import StrOutputParser
from components.prompts import (
    router_prompt_template, 
    medication_prompt_template, 
    symptom_prompt_template
)
# Assuming 'model' is your initialized LLM (e.g. GPT-4)

# --- SETUP CHAINS (Do this once at startup) ---

# Router Chain
# We use 'with_structured_output' if using OpenAI/Pydantic, 
# otherwise use a StrOutputParser and regex/json parsing.
router_chain = router_prompt_template | model.with_structured_output(RouteDecision)

# Specialist Chains
# These are simple LCEL chains: Prompt -> LLM -> String
medication_chain = medication_prompt_template | model | StrOutputParser()
symptom_chain = symptom_prompt_template | model | StrOutputParser()


# --- EXECUTION FLOW ---
async def run_optimized_flow(query_input: str, demo_name: str, chat_history: list):
    
    # 1. Fetch Data (Python side)
    clinical_summary_text = get_clinical_summary(demo_name)
    intent_map_data = get_intent_map(demo_name)
    
    # 2. Route
    route_result = await router_chain.ainvoke({
        "input": query_input, 
        "intent_map": intent_map_data
    })
    
    # 3. Execute
    if route_result.destination == "medication":
        # Notice how the keys here match the {variables} in the imported prompt
        return await medication_chain.ainvoke({
            "input": query_input,
            "chat_history": chat_history,
            "clinical_summary": clinical_summary_text,
            "customer_details": "..." # Add your details here
        })
        
    elif route_result.destination == "symptom":
        return await symptom_chain.ainvoke({
            "input": query_input,
            "chat_history": chat_history,
            "clinical_summary": clinical_summary_text
        })









def upload_pdf_to_s3(local_file_path, s3_filename, bucket_name, folder_prefix, region):
    """
    Uploads PDF using passed arguments instead of global config.
    """
    # Initialize Client (Use the passed region)
    s3_client = boto3.client('s3', region_name=region)

    try:
        s3_key = f"{folder_prefix}{s3_filename}"
        
        # Upload
        s3_client.upload_file(
            local_file_path,
            bucket_name,
            s3_key,
            ExtraArgs={
                'ContentType': 'application/pdf',
                'ContentDisposition': 'attachment'
            }
        )
        
        # Generate URL
        presigned_url = s3_client.generate_presigned_url(
            'get_object',
            Params={'Bucket': bucket_name, 'Key': s3_key},
            ExpiresIn=300
        )
        
        return True, presigned_url

    except ClientError as e:
        print(f"[S3 ERROR] {e}")
        return False, str(e)
    except Exception as e:
        print(f"[S3 ERROR] {e}")
        return False, str(e)






def generate_pdf_report(json_evaluation, sid):
    # ... (All your existing PDF generation logic) ...
    
    # --- C. Upload to S3 ---
    s3_final_name = f"QA_insights_report_{sid}.pdf"
    
    # Retrieve config values here to pass them down
    bucket_name = configuration['S3']['bucket_name']
    folder_prefix = configuration['S3']['folder_prefix']
    region = configuration['S3']['region']

    # PASS THEM EXPLICITLY HERE
    success, result = upload_pdf_to_s3(
        output_path, 
        s3_final_name, 
        bucket_name, 
        folder_prefix, 
        region
    )
    
    # ... (Rest of logic) ...







import os
import boto3
import matplotlib
# CRITICAL: Switch backend to 'Agg' to prevent server crashes on EKS/EC2
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from datetime import datetime
from reportlab.lib.pagesizes import A4
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, Table, TableStyle
from botocore.exceptions import ClientError
import traceback

# ======================================================
# CONFIGURATION SECTION (EDIT THIS)
# ======================================================
configuration = {
    "S3": {
        "bucket_name": "YOUR_BUCKET_NAME_HERE",      # e.g., "highmark-training-ai-file-storage"
        "region": "us-east-1",                       # e.g., "us-east-1"
        "folder_prefix": "evaluation_reports/"       # e.g., "reports/" (Ensure it ends with /)
    }
}

# ======================================================
# 1. Helper: Generate Chart (Thread-Safe)
# ======================================================
def generate_horizontal_bar_chart(categories_score, chart_path):
    """
    Generates a horizontal bar chart and saves it to the specified path.
    Uses a new figure instance to avoid thread contention.
    """
    categories = list(categories_score.keys())
    # Clean percentages (remove %) and convert to float
    scores = [float(v.replace('%', '')) for v in categories_score.values()]

    colors_list = [
        (0.2, 0.4, 1.0, 0.85) if s >= 80 else (1.0, 0.3, 0.3, 0.8)
        for s in scores
    ]

    # Create a specific figure object instead of using global plt instance
    fig, ax = plt.subplots(figsize=(10, 6))
    
    bars = ax.barh(categories, scores, color=colors_list, edgecolor='black')
    
    for i, bar in enumerate(bars):
        ax.text(bar.get_width() + 1, bar.get_y() + bar.get_height()/2, 
                f"{scores[i]}%", va='center', fontsize=10, color='black')
    
    ax.set_xlim(0, 100)
    ax.set_xlabel("Score (%)", fontsize=12)
    ax.set_title("Call Evaluation Analysis", fontsize=14, color='navy', pad=15)
    ax.invert_yaxis()
    ax.grid(axis="x", linestyle="--", alpha=0.4)
    
    plt.tight_layout()
    fig.savefig(chart_path, dpi=300)
    plt.close(fig) # Explicitly close to free memory

# ======================================================
# 2. Helper: Upload & Sign
# ======================================================
def upload_pdf_to_s3(local_file_path, s3_filename):
    """
    Uploads PDF to S3 using the IAM Role and generates a Presigned URL.
    Returns: (success: bool, url_or_error: str)
    """
    # Load config from the dictionary defined at the top
    bucket_name = configuration['S3']['bucket_name']
    region = configuration['S3']['region']
    folder_prefix = configuration['S3']['folder_prefix']
    
    # Initialize Client with Region (Required for SigV4 Presigned URLs)
    s3_client = boto3.client('s3', region_name=region)

    try:
        s3_key = f"{folder_prefix}{s3_filename}"
        
        # 1. Upload File
        s3_client.upload_file(
            local_file_path,
            bucket_name,
            s3_key,
            ExtraArgs={
                'ContentType': 'application/pdf',
                'ContentDisposition': 'attachment'
            }
        )
        
        # 2. Generate Presigned URL (Valid for 5 minutes / 300 seconds)
        presigned_url = s3_client.generate_presigned_url(
            'get_object',
            Params={'Bucket': bucket_name, 'Key': s3_key},
            ExpiresIn=300
        )
        
        print(f"[S3] Upload successful for {s3_filename}")
        return True, presigned_url

    except ClientError as e:
        error_msg = f"S3 ClientError: {str(e)}"
        print(f"[S3 ERROR] {error_msg}")
        return False, error_msg
    except Exception as e:
        error_msg = f"S3 Unexpected Error: {str(e)}"
        print(f"[S3 ERROR] {error_msg}")
        return False, error_msg

# ======================================================
# 3. Main Function: Generate Report
# ======================================================
def generate_pdf_report(json_evaluation, sid):
    """
    Orchestrates PDF creation, chart generation, and S3 upload.
    Returns: Presigned URL (str) or None if failed.
    """
    # Use /tmp for ephemeral storage (safe for Lambda/Containers)
    output_folder = "/tmp" 
    output_filename = f"QA_Insights_Report_{sid}.pdf"
    chart_filename = f"category_scores_chart_{sid}.png"
    
    output_path = os.path.join(output_folder, output_filename)
    chart_path = os.path.join(output_folder, chart_filename)

    try:
        # --- A. Generate Chart ---
        generate_horizontal_bar_chart(json_evaluation.get("Categories_Score", {}), chart_path)

        # --- B. Build PDF Document ---
        doc = SimpleDocTemplate(output_path, pagesize=A4)
        elements = []
        styles = getSampleStyleSheet()
        
        # Custom Styles
        styles.add(ParagraphStyle(name='CustomTitle', fontSize=16, leading=20, spaceAfter=12, textColor=colors.darkblue))
        styles.add(ParagraphStyle(name='SectionHeader', fontSize=13, leading=16, spaceAfter=8, textColor=colors.blue))
        styles.add(ParagraphStyle(name='Body', fontSize










import os
import json
import boto3
import matplotlib
# CRITICAL: Switch backend to 'Agg' before importing pyplot.
# This prevents "TclError: no display name" crashes on headless servers (EKS/EC2).
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from datetime import datetime
from reportlab.lib.pagesizes import A4
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, Table, TableStyle
from botocore.exceptions import ClientError
from config import configuration

# ======================================================
# 1. Helper: Generate Chart (Thread-Safe)
# ======================================================
def generate_horizontal_bar_chart(categories_score, chart_path):
    """
    Generates a horizontal bar chart and saves it to the specified path.
    Uses a new figure instance to avoid thread contention.
    """
    categories = list(categories_score.keys())
    # Clean percentages (remove %) and convert to float
    scores = [float(v.replace('%', '')) for v in categories_score.values()]

    colors_list = [
        (0.2, 0.4, 1.0, 0.85) if s >= 80 else (1.0, 0.3, 0.3, 0.8)
        for s in scores
    ]

    # Create a specific figure object instead of using global plt instance
    fig, ax = plt.subplots(figsize=(10, 6))
    
    bars = ax.barh(categories, scores, color=colors_list, edgecolor='black')
    
    for i, bar in enumerate(bars):
        ax.text(bar.get_width() + 1, bar.get_y() + bar.get_height()/2, 
                f"{scores[i]}%", va='center', fontsize=10, color='black')
    
    ax.set_xlim(0, 100)
    ax.set_xlabel("Score (%)", fontsize=12)
    ax.set_title("Call Evaluation Analysis", fontsize=14, color='navy', pad=15)
    ax.invert_yaxis()
    ax.grid(axis="x", linestyle="--", alpha=0.4)
    
    plt.tight_layout()
    fig.savefig(chart_path, dpi=300)
    plt.close(fig) # Explicitly close to free memory

# ======================================================
# 2. Helper: Upload & Sign
# ======================================================
def upload_pdf_to_s3(local_file_path, s3_filename):
    """
    Uploads PDF to S3 using the IAM Role and generates a Presigned URL.
    Returns: (success: bool, url_or_error: str)
    """
    bucket_name = configuration['S3']['bucket_name']
    region = configuration['S3']['region']
    folder_prefix = configuration['S3']['folder_prefix']
    
    # Initialize Client with Region (Required for SigV4 Presigned URLs)
    # No keys needed - Boto3 automatically picks up the EKS/IAM Role.
    s3_client = boto3.client('s3', region_name=region)

    try:
        s3_key = f"{folder_prefix}{s3_filename}"
        
        # 1. Upload File
        s3_client.upload_file(
            local_file_path,
            bucket_name,
            s3_key,
            ExtraArgs={
                'ContentType': 'application/pdf',
                # Forces browser to download with specific filename
                'ContentDisposition': 'attachment' 
            }
        )
        
        # 2. Generate Presigned URL (Valid for 5 minutes / 300 seconds)
        presigned_url = s3_client.generate_presigned_url(
            'get_object',
            Params={'Bucket': bucket_name, 'Key': s3_key},
            ExpiresIn=300
        )
        
        print(f"[S3] Upload successful for {s3_filename}")
        return True, presigned_url

    except ClientError as e:
        error_msg = f"S3 ClientError: {str(e)}"
        print(f"[S3 ERROR] {error_msg}")
        return False, error_msg
    except Exception as e:
        error_msg = f"S3 Unexpected Error: {str(e)}"
        print(f"[S3 ERROR] {error_msg}")
        return False, error_msg

# ======================================================
# 3. Main Function: Generate Report
# ======================================================
def generate_pdf_report(json_evaluation, sid):
    """
    Orchestrates PDF creation, chart generation, and S3 upload.
    Handles cleanup of temporary files in /tmp.
    Returns: Presigned URL (str) or None if failed.
    """
    # Use /tmp for ephemeral storage (safe for Lambda/Containers)
    output_folder = "/tmp" 
    output_filename = f"QA_Insights_Report_{sid}.pdf"
    chart_filename = f"category_scores_chart_{sid}.png"
    
    output_path = os.path.join(output_folder, output_filename)
    chart_path = os.path.join(output_folder, chart_filename)

    try:
        # --- A. Generate Chart ---
        generate_horizontal_bar_chart(json_evaluation.get("Categories_Score", {}), chart_path)

        # --- B. Build PDF Document ---
        doc = SimpleDocTemplate(output_path, pagesize=A4)
        elements = []
        styles = getSampleStyleSheet()
        
        # Custom Styles
        styles.add(ParagraphStyle(name='CustomTitle', fontSize=16, leading=20, spaceAfter=12, textColor=colors.darkblue))
        styles.add(ParagraphStyle(name='SectionHeader', fontSize=13, leading=16, spaceAfter=8, textColor=colors.blue))
        styles.add(ParagraphStyle(name='Body', fontSize=10, leading=14))
        cell_style = ParagraphStyle(name='TableCell', fontSize=10, leading=12, spaceAfter=2)

        # Content: Title & Time
        elements.append(Paragraph("<b>Call Simulation Evaluation Report</b>", styles['CustomTitle']))
        elements.append(Spacer(1, 10))
        elements.append(Paragraph(f"<b>Report Generated:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", styles['Body']))
        elements.append(Spacer(1, 10))

        # Content: Score
        overall_score = float(json_evaluation.get("Overall_Score", "0%").replace("%", ""))
        status = "PASS" if overall_score >= 80 else "FAIL"
        status_color = "green" if status == "PASS" else "red"
        
        elements.append(Paragraph(f"<b>Overall Score:</b> {overall_score}%", styles['Body']))
        elements.append(Paragraph(f"<b>Status:</b> <font color='{status_color}'><b>{status}</b></font>", styles['Body']))
        elements.append(Spacer(1, 12))

        # Content: Chart Image
        if os.path.exists(chart_path):
            elements.append(Image(chart_path, width=480, height=280))
            elements.append(Spacer(1, 12))

        # Content: Detailed Table
        for section, data in json_evaluation.items():
            if isinstance(data, dict) and "sub_parameters" in data:
                elements.append(Paragraph(f"<b>{section}</b>", styles['SectionHeader']))
                table_data = [["Description"]]
                for sub in data["sub_parameters"]:
                    table_data.append([Paragraph(sub.get("description", ""), cell_style)])

                table = Table(table_data, colWidths=[460])
                table.setStyle(TableStyle([
                    ("BACKGROUND", (0, 0), (-1, 0), colors.lightblue),
                    ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                    ("ALIGN", (0, 0), (-1, -1), "LEFT"),
                    ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                    ("BOTTOMPADDING", (0, 0), (-1, 0), 6),
                    ("BACKGROUND", (0, 1), (-1, -1), colors.beige),
                    ("GRID", (0, 0), (-1, -1), 0.25, colors.gray),
                ]))
                elements.append(table)
                elements.append(Spacer(1, 12))

        # Content: Recommendations
        if "Recommendation" in json_evaluation:
            elements.append(Paragraph("<b>Recommendations</b>", styles['SectionHeader']))
            for rec in json_evaluation["Recommendation"]:
                elements.append(Paragraph(f"â€¢ {rec}", styles['Body']))
            elements.append(Spacer(1, 10))

        # Write PDF to /tmp
        doc.build(elements)

        # --- C. Upload to S3 ---
        s3_final_name = f"QA_insights_report_{sid}.pdf"
        success, result = upload_pdf_to_s3(output_path, s3_final_name)
        
        if success:
            return result # This is the Presigned URL
        else:
            print(f"Failed to return URL. Error: {result}")
            return None

    except Exception as e:
        print(f"CRITICAL ERROR in PDF Generation: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

    finally:
        # --- D. Cleanup (Always runs) ---
        # Crucial for servers to avoid 'Disk Full' errors
        if os.path.exists(output_path):
            os.remove(output_path)
        if os.path.exists(chart_path):
            os.remove(chart_path)












def upload_pdf_to_s3(local_file_path, s3_filename):
    """
    Uploads PDF and returns the DIRECT (Permanent) URL.
    NOTE: This URL will only work if the bucket is PUBLIC or the user has direct AWS access.
    """
    bucket_name = configuration['S3']['bucket_name']
    region = configuration['S3']['region']
    folder_prefix = configuration['S3']['folder_prefix']
    
    # Initialize Client (Still need region for upload to work correctly)
    s3_client = boto3.client('s3', region_name=region)

    try:
        s3_key = f"{folder_prefix}{s3_filename}"
        
        # 1. Upload File
        s3_client.upload_file(
            local_file_path,
            bucket_name,
            s3_key,
            ExtraArgs={
                'ContentType': 'application/pdf',
                'ContentDisposition': 'attachment' # Still good to keep
            }
        )
        
        # 2. Construct Direct URL (Traditional Way)
        # Format: https://{bucket}.s3.{region}.amazonaws.com/{key}
        direct_url = f"https://{bucket_name}.s3.{region}.amazonaws.com/{s3_key}"
        
        print(f"[S3] Upload successful. Direct URL: {direct_url}")
        return True, direct_url

    except ClientError as e:
        print(f"[S3 ERROR] {e}")
        return False, str(e)
