from typing import Optional, Dict, Any
from pydantic import BaseModel

# --- 1. DEFINE THE PAYLOAD MODEL (Matches Frontend/Old Code) ---
class UserQuery(BaseModel):
    domain: str
    demo_name: str
    user_input: str
    persona: str
    session_id: Optional[str] = ''  # Frontend sends empty string '' for new calls
    scenario: str
    customer_details: Optional[Dict[str, Any]] = {}
    n_question: Optional[str] = ''
    closing_turn: Optional[str] = ''
    utils: Optional[Dict[str, Any]] = {}

# --- 2. THE UPDATED ENDPOINT ---
@app.post("/aa-api/v1/utility/get_query")
async def chat(query: UserQuery):
    try:
        # A. HANDLE SESSION ID (Frontend sends '' for new calls)
        sid = query.session_id
        if not sid or sid == "":
            sid = f"AA-{uuid.uuid4()}"
            print(f"üÜï New Call Started via Frontend. Assigned SID: {sid}")

        # B. RETRIEVE OR HEAL SESSION
        session_data = session_store.get_object(sid)
        
        is_invalid = False
        if session_data is None:
            is_invalid = True
        elif isinstance(session_data, dict) and "Message" in session_data:
            is_invalid = True
        elif isinstance(session_data, dict) and "chat_history" not in session_data:
            is_invalid = True

        if is_invalid:
            print(f"‚ö†Ô∏è Initializing fresh session for {sid}")
            # We store the customer_details from frontend into state, 
            # just in case we want to use them dynamically later.
            session_data = {
                "chat_history": [],
                "state": {
                    "customer_details": query.customer_details,
                    "persona": query.persona,
                    "domain": query.domain
                },
                "agent_states": []
            }
            session_store.add_object(sid, session_data)

        # C. PREPARE INPUTS
        chat_history = session_data["chat_history"]
        
        # Add User Message to History
        chat_history.append(HumanMessage(content=query.user_input))
        session_store.update_chat_history(sid, HumanMessage(content=query.user_input))

        agent_inputs = {
            "input": query.user_input,
            "chat_history": chat_history
        }

        # D. EXECUTE AGENT
        result = await main_agent.ainvoke(agent_inputs)
        output_text = result.get("output", str(result))

        # E. UPDATE MEMORY
        chat_history.append(AIMessage(content=output_text))
        session_store.update_chat_history(sid, AIMessage(content=output_text))
        
        try:
            session_store.update_node(sid)
        except:
            pass

        # F. DETERMINE CALL STATUS (For Frontend Logic)
        # If the agent says "Goodbye", tell frontend to terminate
        call_status = "active"
        if "goodbye" in output_text.lower() or "have a nice day" in output_text.lower():
            call_status = "terminated"

        # G. RETURN RESPONSE (Mapped to fit Frontend expectations)
        # The frontend expects 'answer' dict inside the response usually, 
        # or at least a structure it can parse. 
        # Based on your request, I will return the clean structure but 
        # ensure it accepts the Input Payload successfully.
        
        return {
            "response": output_text, # Standard new field
            "answer": {              # Backward compatibility field (if frontend uses this)
                "customer_query": output_text,
                "call_status": call_status
            },
            "session_id": sid,
            "Agent_states": []
        }

    except Exception as e:
        print("‚ùå CRITICAL ERROR IN CHAT ENDPOINT:")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Server Error: {str(e)}")
