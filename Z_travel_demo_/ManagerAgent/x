@app.post("/aa-api/v1/utility/get_query")
async def chat(query: UserQuery):
    try:
        # --- 1. SESSION ID MANAGEMENT ---
        sid = query.session_id
        if not sid or sid == "":
            sid = f"AA-{uuid.uuid4()}"
            print(f"üÜï New Call Started. Assigned SID: {sid}")

        # --- 2. RETRIEVE OR HEAL SESSION ---
        session_data = session_store.get_object(sid)
        
        # Check validity
        is_invalid = False
        if session_data is None:
            is_invalid = True
        elif isinstance(session_data, dict) and "Message" in session_data:
            is_invalid = True
        elif isinstance(session_data, dict) and "chat_history" not in session_data:
            is_invalid = True

        if is_invalid:
            print(f"‚ö†Ô∏è Initializing fresh session for {sid}")
            session_data = {
                "chat_history": [],
                "state": {}, 
                "agent_states": []
            }
            session_store.add_object(sid, session_data)

        # --- 3. ONE-TIME STATE INITIALIZATION (The Logic You Requested) ---
        
        current_state = session_data["state"]
        
        # LOGIC: Only update IF payload has details AND state is currently empty of details.
        # This prevents overwriting if the frontend sends empty details later.
        if query.customer_details and not current_state.get("customer_details"):
            
            print(f"üîí Locking in Customer Details for Session {sid} (One-Time Setup)")
            
            # 1. Save Customer Details
            session_data["state"]["customer_details"] = query.customer_details
            
            # 2. Save Metadata (Persona/Domain)
            session_data["state"]["persona"] = query.persona
            session_data["state"]["domain"] = query.domain
            
            # 3. Commit to Store
            session_store.add_object(sid, session_data)
        
        else:
            # Optional: Debug log to show we are using existing memory
            # print(f"‚ÑπÔ∏è Using existing state for {sid}")
            pass

        # --- 4. PREPARE INPUTS ---
        chat_history = session_data["chat_history"]
        
        chat_history.append(HumanMessage(content=query.user_input))
        session_store.update_chat_history(sid, HumanMessage(content=query.user_input))

        # We pass the state to the agent inputs so the agent can see the details
        # regardless of whether they were set just now or 10 turns ago.
        agent_inputs = {
            "input": query.user_input,
            "chat_history": chat_history,
            "state": session_data["state"] # Pass the persistent state
        }

        # --- 5. EXECUTE AGENT ---
        result = await main_agent.ainvoke(agent_inputs)
        output_text = result.get("output", str(result))

        # --- 6. UPDATE MEMORY ---
        chat_history.append(AIMessage(content=output_text))
        session_store.update_chat_history(sid, AIMessage(content=output_text))
        
        try:
            session_store.update_node(sid)
        except:
            pass

        # --- 7. RETURN RESPONSE ---
        call_status = "active"
        if "goodbye" in output_text.lower() or "have a nice day" in output_text.lower():
            call_status = "terminated"
        
        return {
            "response": output_text,
            "answer": {
                "customer_query": output_text,
                "call_status": call_status
            },
            "session_id": sid,
            "Agent_states": []
        }

    except Exception as e:
        print("‚ùå CRITICAL ERROR IN CHAT ENDPOINT:")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Server Error: {str(e)}")
